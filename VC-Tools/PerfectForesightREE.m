function [REE,eu] = PerfectForesightREE(StateEq,RegIdx,Innovations,varargin)

% PerfectForesightREE
%
% Solve for the REE sequence of matrices in a (possibly) regime switching
% economy with perfect foresight.
%
% Inputs
% ------
%
% StateEq
%   Structure with as many elements as regimes and for each element it has
% the following fields: Gamma0, Gamma1,GammaBar, Gamma2, Gamma3, such that
% we have backward looking (BL) equations written in the form
%     Gamma0*z{t} = GammaBar + Gamma1*z{t-1} + Gamma2*eps{t}
% and forward looking (FL) equations in the form
%     Gamma0*z{t+1} = GammaBar + Gamma1*z{t} + Gamma3*eta{t+1}
%   Notice that the system is written as big matrix including BL and FL. It
% does no require any given order of FL and BL equations and they can be
% interchanged, as long as any given equation is written in one of the
% above forms (no hybrids allowed).
%   This way of writing the system is thus consistent with the gensys
% setup, where z is the vector of all state space variables, eps is the
% vector of all innovations and eta the vector of all endogenous
% expectational errors.
%   Based on these matrices, the code will split the code into forward
% looking and backward looking equations as needed.
%
% RegIdx
%   Vector array containing the index of the regime that applies to that
% period. The last element determines which regime is used as the absorbing
% state, beyond which there are no expected regime changes nor innovations.
%
% Innovations (optional)
%   Sequence of expected innovations that need to be incorporated into the
% numerical solution. Needs to have as many rows as the nummber of
% exogenous innovations in the model (as many as the columns in Gamma2) and
% as many columns as the number of periods under perfect foresight.
%   Default: zeros (no expected future innovations)
%
% Outputs
% -------
%
% REE
%   Structure with the following fields: Phi0, Phi1 and Phi2, such that the
% reduced form solution can be written as
%     z{t} = REE(t).GBar + REE(t).G1*z{t-1} + REE(t).G2*eps{t}
% and the length of REE is the same as RegIdx and Innovations.
%
% eu
%   return code generated by gensys for the last period REE solution.
%
% .........................................................................
%
% Created: September 21, 2010 by Vasco Curdia
%          Originally called ZLBREE
% Updated: July 21, 2011 by Vasco Curdia
%          Changed notation to use the same as in Estimation codes.
% Updated: July 26, 2011 by Vasco Curdia
% Updated: November 13, 2013 by Vasco Curdia
%  - Changed notation to GBar, G1 and G2
% Updated: January 2, 2014 by Vasco Curdia
%  - added varargin to pass optional arguments to vcgensys
%
% Copyright 2010-2014 by Vasco Curdia

%% ------------------------------------------------------------------------

%% Preamble
REE = struct('GBar',{},'G1',{},'G2',{});
T = length(RegIdx);
nReg = length(StateEq);
MatList = {'Gamma0','Gamma1','GammaBar','Gamma2','Gamma3'};
nMatList = 5;
isInnovations = exist('Innovations','var') && ~isempty(Innovations);

%% Run checks
if isInnovations && (size(Innovations,2)~=T)
  error('RegIdx length needs to be the same as number of columns in Innovations.')
end
for t=1:nReg
  for j=1:nMatList
    eval(sprintf('%1$s = StateEq(t).%1$s;',MatList{j}))
  end
  cv = ~all(Gamma3==0,2);
  if ~all(all(Gamma2(cv,:)==0))
    error('Forward Looking equations cannot respond to innovations.\n')
  end
end

%% Run gensys
for j=1:nMatList
  eval(sprintf('%1$s = StateEq(RegIdx(T)).%1$s;',MatList{j}))
end
[G1,GBar,G2,~,~,~,~,eu] = ...
  vcgensys(Gamma0,Gamma1,GammaBar,Gamma2,Gamma3,varargin{:});
% if any(eu~=1),fprintf('WARNING: eu = (%.0f,%.0f)\n',eu),end
REE(T).GBar = GBar;
REE(T).G1 = G1;
REE(T).G2 = G2;

%% Recursive REE solution
for t=T-1:-1:1
  for j=1:nMatList
    eval(sprintf('%1$s = StateEq(RegIdx(t)).%1$s;',MatList{j}))
  end
  cv = ~all(Gamma3==0,2);
  if isInnovations
    GammaBar(cv) = GammaBar(cv)-Gamma0(cv,:)*(REE(t+1).GBar+...
      REE(t+1).G2*Innovations(:,t+1));
  else
    GammaBar(cv) = GammaBar(cv)-Gamma0(cv,:)*REE(t+1).GBar;
  end
  Gamma0(cv,:) = Gamma0(cv,:)*REE(t+1).G1-Gamma1(cv,:);
  Gamma1(cv,:) = 0;
  %     Gamma4inv = rbinv(Gamma4);
  Gamma0inv = pinv(Gamma0);
  REE(t).GBar = Gamma0inv*GammaBar;
  REE(t).G1 = Gamma0inv*Gamma1;
  REE(t).G2 = Gamma0inv*Gamma2;
end

%% ------------------------------------------------------------------------
